@{
    Layout = "~/Views/Shared/_Documenation.cshtml";
    ViewBag.Title = "ImVader | Documentation";
}

<div class="jumbotron">
    <h2 style="font-size: 300%;border-bottom: none; margin-bottom: 50px;">ImVader</h2>
    <p>
        ImVader is a flexible and powerful .NET framework for working with graphs. The project is hosted on <a href="https://github.com/Konnor95/ImVader/" target="_blank">Github</a> and is absolutely free.
    </p>
    <p>
        P.S. Project development is in alpha version, you should not use this framework in commercial projects yet.
    </p>
    <p>
        <a class="btn btn-primary btn-lg" href="https://github.com/Konnor95/ImVader/" target="_blank">Fork us on Github <i class="fa fa-arrow-circle-right"></i></a>
        <a class="btn btn-primary btn-lg" href="~/VSdoc/index.html">Full reference <i class="fa fa-arrow-circle-right"></i></a>
        <a class="btn btn-primary btn-lg" href="https://www.nuget.org/packages/ImvaderPackage/">Download <i class="fa fa-arrow-circle-right"></i></a>
    </p>
</div>
<div>
    <h2>Requirements</h2>
    <br>
    <p class="well">
        ImVader requires .NET 4.5 to be installed
    </p>
    <br>
</div>
<div>
    <h2 id="anchor-graph">Example usage</h2>
    <div>
        <h3>Initialiazing graph</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
//Initializing new list-base graph (vertices store integer values, edges are unweighted)
var m = new ListGraph&lt;int, UnweightedEdge&gt;();
//Adding vertices
int v0 = m.AddVertex(32);
int v1 = m.AddVertex(13);
int v2 = m.AddVertex(23);
int v3 = m.AddVertex(84);
int v4 = m.AddVertex(64);
//Adding edges
m.AddEdge(new UnweightedEdge(v0, v1));
m.AddEdge(new UnweightedEdge(v0, v4));
m.AddEdge(new UnweightedEdge(v0, v2));
m.AddEdge(new UnweightedEdge(v1, v2));
m.AddEdge(new UnweightedEdge(v1, v3));
m.AddEdge(new UnweightedEdge(v3, v4));
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Managing graph</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
// Initializing new list-base weighted graph with 10 vertices and 1 edge with weight 23.5
var m = new ListGraph&lt;int, WeightedEdge&gt;(10);
int edge0 = m.AddEdge(new WeightedEdge(0, 1, 23.5));
// Setting the vertex with index 2 value 32
m.SetVertexData(2, 32);
// Removing vertex with index 2
m.RemoveVertex(2);
// Setting the edge with index edge0 weight 33
m.GetEdge(edge0).Weight = 33;
// Removing edge with index edge0
m.RemoveVertex(edge0);
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Breadth-first search</h3>
        <br />
        <div>
            <pre>
            <code data-language="csharp">
var dirListGraph = new DirectedListGraph&lt;int, edge&gt;(5);
dirListGraph.AddEdge(new UnweightedEdge(0, 1));
dirListGraph.AddEdge(new UnweightedEdge(1, 3));
dirListGraph.AddEdge(new UnweightedEdge(0, 2));
dirListGraph.AddEdge(new UnweightedEdge(0, 3));
dirListGraph.AddEdge(new UnweightedEdge(3, 4));
var bfs = new BreadthFirstPathes&lt;int, edge&gt;(dirListGraph, 0);
var path = bfs.PathTo(4).ToArray();
foreach (var vertexId in path)
{
    Console.WriteLine(vertexId);
}
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Depth-first search</h3>
        <br />
        <div>
            <pre>
            <code data-language="csharp">
var dirListGraph = new DirectedListGraph&lt;int, edge&gt;(5);
dirListGraph.AddEdge(new UnweightedEdge(0, 1));
dirListGraph.AddEdge(new UnweightedEdge(1, 3));
dirListGraph.AddEdge(new UnweightedEdge(0, 2));
dirListGraph.AddEdge(new UnweightedEdge(0, 3));
dirListGraph.AddEdge(new UnweightedEdge(3, 4));
var bfs = new DepthFirstPathes&lt;int, edge&gt;(dirListGraph, 0);
var path = bfs.PathTo(4).ToArray();
foreach (var vertexId in path)
{
    Console.WriteLine(vertexId);
}
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Minimum cuts</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
var matrixGraph = new MatrixGraph&lt;int, WeightedEdge&gt;(4);
matrixGraph.AddEdge(new WeightedEdge(0, 1, 1));
matrixGraph.AddEdge(new WeightedEdge(1, 2, 4));
matrixGraph.AddEdge(new WeightedEdge(2, 3, 1));
matrixGraph.AddEdge(new WeightedEdge(3, 0, 10));
var minCuts = new MinimumCuts&lt;int, WeightedEdge&gt;(matrixGraph);
foreach (var vertexId in BestCut)
{
    Console.WriteLine(vertexId);
}           
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Minimal spanning tree</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
var matrixGraph = new ListGraph&lt;int, WeightedEdge&gt;(6);
g.AddEdge(new WeightedEdge(0, 1, 2));
g.AddEdge(new WeightedEdge(1, 3, 1));
g.AddEdge(new WeightedEdge(2, 4, 3));
g.AddEdge(new WeightedEdge(2, 3, 10));
g.AddEdge(new WeightedEdge(0, 1, 2));
g.AddEdge(new WeightedEdge(3, 5, 2));
g.AddEdge(new WeightedEdge(4, 5, 5));
var mst = new MinimalSpanningTree&lt;int, WeightedEdge&gt;(g);
Console.WriteLine(mst.GetMstWeight()); // prints 13.0       
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Strong components</h3>
        <br />
        <div>
            <pre>
            <code data-language="csharp">
var g = new DirectedListGraph&lt;int, UnweightedEdge&gt;(6);
g.AddEdge(new UnweightedEdge(0, 1));
g.AddEdge(new UnweightedEdge(2, 0));
g.AddEdge(new UnweightedEdge(2, 1));
g.AddEdge(new UnweightedEdge(3, 4));
g.AddEdge(new UnweightedEdge(4, 5));
g.AddEdge(new UnweightedEdge(5, 3));
var strongComponents = new StrongComponents&lt;int, edge&gt;(g);     
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Floyd-Worshell algorithm (the shortest path)</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
var g = new ListGraph&lt;int, WeightedEdge&gt;(5);
g.AddEdge(new WeightedEdge(0, 1, 1));
g.AddEdge(new WeightedEdge(0, 2, 1));
g.AddEdge(new WeightedEdge(1, 2, 1));
g.AddEdge(new WeightedEdge(3, 4, 1));
g.AddEdge(new WeightedEdge(1, 4, 1));
var res = g.GetShortestPathesList();    
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Dijkstra algorithm (the shortest path)</h3>
        <br />
        <div>
            <pre>
<code data-language="csharp">
var m = new DirectedListGraph&lt;int, Weightededge&gt;(6);
m.AddEdge(new WeightedEdge(0, 2, 1));
m.AddEdge(new WeightedEdge(0, 1, 7));
m.AddEdge(new WeightedEdge(0, 5, 4));
m.AddEdge(new WeightedEdge(5, 3, 4));
m.AddEdge(new WeightedEdge(4, 3, 1));
m.AddEdge(new WeightedEdge(3, 2, 2));
m.AddEdge(new WeightedEdge(2, 4, 3));
m.AddEdge(new WeightedEdge(2, 1, 3));
var d = new Dijkstra&lt;int, weightededge&gt;(m, 0);
var path = d.PathTo(3);    
</code>
</pre>
        </div>
    </div>
    <div>
        <h3>Topological sort</h3>
        <br />
        <div>
            <pre>
                <code data-language="csharp">
var g = new ListGraph&lt;int, WeightedEdge&gt;(4);
g.AddEdge(new WeightedEdge(0, 2, 1));
g.AddEdge(new WeightedEdge(0, 1, 1));
g.AddEdge(new WeightedEdge(1, 3, 1));
g.AddEdge(new WeightedEdge(2, 1, 1));
g.AddEdge(new WeightedEdge(2, 3, 1));
var topSort = new TopologicalSort&lt;int, WeightedEdge&gt;();
topSort.SortGraph(g);
var order = topSort.GetOrder();  
</code>
</pre>
        </div>
    </div>
</div>

<h2>Code map</h2>
<p class="well">
    If you want to understand the whole stucture of the framework, you can look through the <a href="~/Images/CodeMap.png" target="_blank">code map</a> of the framework.
</p>
<br>
